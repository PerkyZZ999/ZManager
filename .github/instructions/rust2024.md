---
description: 'Rust (Edition 2024) programming language coding conventions and best practices'
applyTo: '**/*.rs'
---

# Rust Best Practices and Standards (Rust Edition 2024)

> **Purpose ** — This guide establishes a single source-of-truth for writing modern, idiomatic, *secure*, and *high-performance* Rust across all projects.

---

## Table of Contents

1. [Overview](#overview)
2. [General Development Guidelines](#general-development-guidelines)
3. [Code Organization and Architecture](#code-organization-and-architecture)
4. [Rust 2024 Edition Features](#rust-2024-edition-features)
5. [Memory Safety and Ownership](#memory-safety-and-ownership)
6. [Error Handling Patterns](#error-handling-patterns)
7. [Type System and Generics](#type-system-and-generics)
8. [Performance Optimization](#performance-optimization)
9. [Concurrency and Async Programming](#concurrency-and-async-programming)
10. [Security Best Practices](#security-best-practices)
11. [Testing Strategies](#testing-strategies)
12. [Documentation Standards](#documentation-standards)
13. [Code Style and Formatting](#code-style-and-formatting)
14. [Project Structure](#project-structure)
15. [Essential Crates and Ecosystem](#essential-crates-and-ecosystem)
16. [Debugging and Tooling](#debugging-and-tooling)

---

## Overview

Rust’s promise is *fearless concurrency* and *zero-cost abstractions* without sacrificing ergonomics. These rules ensure that every engineer:

* Ships **memory-safe** code free of undefined behavior.
* Adopts **idiomatic** patterns the compiler can optimize.
* Embeds **security** defenses by default.
* Maintains **readability** that scales to large teams.

> **Golden rule:** *If the compiler can prevent a bug today, do not defer it to runtime.*

---

## General Development Guidelines

### Core Principles

1. **Safety First** — Prefer safe Rust. `unsafe` must be *audited*, *documented*, and *unit-tested*.
2. **Minimal Surface Area** — Expose only what consumers need via `pub(crate)` and `pub use` re-exports.
3. **Explicitness Over Implicitness** — Favour named types, exhaustive matches, and builder patterns to clarify intent.
4. **Fail Fast & Loud** — Treat `expect`/`unwrap` as last resort; annotate with a justification comment.
5. **Tooling as CI Gatekeeper** — CI must run `cargo clippy --deny warnings`, `cargo fmt --check`, and `cargo test --all-features` on every PR.

### Recommended Workflow

```bash
# 1. Watch for compile errors & Clippy lints on save
cargo watch -x 'clippy --workspace --all-targets -- -D warnings' \
           -x 'test --workspace --all-features'

# 2. Format staged files
cargo fmt --all

# 3. Run the minimal fast check cycle
cargo check --workspace --all-targets

# 4. Full release simulation
cargo build --release --workspace
```

---

## Code Organization and Architecture

### Module & Namespace Rules

| Guideline                                                                                                  | Rationale                                            |
| ---------------------------------------------------------------------------------------------------------- | ---------------------------------------------------- |
| `mod` is **private** by default. Promote to `pub(crate)` instead of `pub` unless library boundary demands. | Containing crate remains free to refactor internals. |
| Group *domain objects* by **feature**, not by technical layer.                                             | Improves locality & discoverability.                 |
| Use `pub use crate::foo::Bar` to expose a flat public API.                                                 | Consumers avoid deep paths.                          |

```rust
// src/lib.rs
mod domain;          // internal details
pub use domain::api; // re-export top-level façade only
```

### Layering Example

```
my_app/
├── src/
│   ├── api/           # HTTP handlers, GraphQL, gRPC
│   ├── domain/        # Pure business logic, no I/O
│   ├── infra/         # DB, cache, queues, external APIs
│   └── lib.rs         # Public surface; re-exports
└── tests/             # Black-box integration tests
```

### Dependency Management

* **Pin major versions** to avoid SEMVER breakages.
* Use **cargo deny** to prevent duplicate transitive versions.
* Prefer feature-gated optional deps so binaries remain slim.

```toml
[dependencies]
serde = { version = "1.0", default-features = false, features = ["derive"] }
# Gate AWS support behind a feature flag
aws-sdk-s3 = { version = "1", optional = true }

[features]
default = []
s3 = ["aws-sdk-s3"]
```

---

## Rust 2024 Edition Features

| Feature                    | Usage Tip                                                            | Example                                            |
| -------------------------- | -------------------------------------------------------------------- | -------------------------------------------------- |
| **Async closures**         | Replace ad-hoc `async move` blocks for callbacks.                    | `let f = async                                     | req                                                        | handle(req).await;` |
| **`impl Trait` in traits** | Simplifies associated-type clutter.                                  | `fn encode(&self) -> impl Future<Output = Bytes>;` |
| **Pattern-guard flows**    | Use `if let`/`while let` plus or-patterns for expressive matching.   | `match (cmd, user) { ("run"                        | "exec", Some(u)) if u.is_admin() => { ... } _ => deny() }` |
| **`for ... each` loops**   | Write `for #[attr] pat in expr {}` with per-item attributes.         |
| **`#[expect(lint)]`**      | Semver-safe suppression of *specific* Clippy failure expected paths. |

> **Migration hint :** run `cargo fix --edition 2024` then address lint suggestions manually.

---

## Memory Safety and Ownership

### Borrowing Rules Cheatsheet

* Exactly **one** mutable reference *or* unlimited shared refs.
* Lifetimes **annotate relationships**, *not durations*.
* **Slice First**: prefer `&[T]` & `&str` to `Vec<T>` & `String` in APIs.

#### Common Pitfalls & Remedies

| Issue                              | Symptom                                     | Solution                                                            |
| ---------------------------------- | ------------------------------------------- | ------------------------------------------------------------------- |
| Dangling reference                 | borrow checker error about shorter lifetime | Clone into owned type (`String`) or restructure to own parent data. |
| Multiple mutable borrows           | cannot borrow as mutable more than once     | Use scoped block, `RefCell`, or functional style to split phases.   |
| Need runtime-length array on stack | `T` requires known size                     | Use const generics `<const N: usize>` so compiler knows size.       |

#### Example — Streaming Parser Without Copies

```rust
pub struct Csv<'a> {
    input: &'a [u8],
    pos: usize,
}

impl<'a> Iterator for Csv<'a> {
    type Item = &'a [u8];

    fn next(&mut self) -> Option<Self::Item> {
        if self.pos >= self.input.len() { return None; }
        let start = self.pos;
        while self.pos < self.input.len() && self.input[self.pos] != b'\n' { self.pos += 1; }
        let line = &self.input[start..self.pos];
        self.pos += 1; // skip newline
        Some(line)
    }
}
```
*Zero allocations; lifetimes ensure `Csv` never outlives input slice.*

---

## Error Handling Patterns

### 1. Rich Domain Errors

```rust
#[derive(thiserror::Error, Debug)]
pub enum AuthError {
    #[error("database unavailable: {0}")]
    Db(#[from] sqlx::Error),
    #[error("invalid credentials")]
    InvalidCredentials,
    #[error("token expired at {expired:?}")]
    Expired { expired: DateTime<Utc> },
}
```

### 2. Propagation with `?` Operator

```rust
async fn login(req: LoginReq) -> Result<Token, AuthError> {
    let user = fetch_user(&req.email).await?;
    user.verify(&req.password)?;
    Ok(generate_token(user)?)
}
```

### 3. Recoverable vs Fatal

```rust
match cache.get(key) {
    Ok(Some(val)) => return Ok(val),
    Ok(None) => fetch_and_store(key).await,
    Err(e) if e.is_transient() => retry(e).await,
    Err(e) => Err(CacheLayer::from(e)), // escalate
}
```

### 4. `anyhow` for Binaries

In CLI and one-off binaries, trade structured errors for quick context.

```rust
use anyhow::{Context, Result};

fn main() -> Result<()> {
    let cfg = std::fs::read("config.toml")
        .context("reading configuration file")?;
    run(cfg)?;
    Ok(())
}
```

---

## Type System and Generics

### Const Generics for Compile-Time Safety

```rust
struct FixedStr<const N: usize> {
    inner: [u8; N],
}

impl<const N: usize> FixedStr<N> {
    pub fn new(bytes: [u8; N]) -> Self { Self { inner: bytes } }
}

let msg = FixedStr::<5>::new(*b"hello");
```

### Phantom Types for State Machines

```rust
use std::marker::PhantomData;

struct Request<S> { id: u64, _state: PhantomData<S> }
struct New; struct Validated;

impl Request<New> {
    fn validate(self) -> Request<Validated> { /* ... */ }
}

impl Request<Validated> {
    fn send(self) { /* cannot send until validated */ }
}
```

### Blanket Trait Implementations

```rust
trait Printable {
    fn print(&self);
}

impl<T: std::fmt::Debug> Printable for T {
    fn print(&self) { println!("{:?}", self); }
}

42.print(); // works for any Debug type
```

---

## Performance Optimization

1. **Profile before optimizing.** Use `cargo flamegraph`, `cargo profiler`, or `tokio-console`.
2. **Data-Oriented Design.** Prefer contiguous `Vec<T>` over `HashMap` for hot loops.
3. **Minimize allocations.** Use `SmallVec`, `bytes::Bytes`, or arena allocators (`typed-arena`).
4. **Cache-friendly enums.** Use `#[repr(u8)]` on C-style enums in dense arrays.
5. **SIMD & BLAS.** Use `packed_simd_2`, `wide`, or crate-level features (`simd-json`).
6. **Compile-time compute.** Leverage `const fn` for tables.

#### Example — Arena Allocation

```rust
use bumpalo::Bump;

fn build_tree(ids: &[u32]) -> NodeRef {
    let arena = Bump::new();
    let root = arena.alloc(Node::new("root"));
    for id in ids {
        root.children.push(arena.alloc(Node::new(id.to_string())));
    }
    root
}
```
*Single bump allocator per request dramatically reduces `malloc` overhead.*

---

## Concurrency and Async Programming

### Structured Concurrency with `tokio::task::JoinSet`

```rust
let mut set = JoinSet::new();
for url in urls {
    set.spawn(download(url));
}
while let Some(res) = set.join_next().await {
    handle(res?)?;
}
```

### Cancellation & Timeouts

```rust
use tokio::time::{timeout, Duration};

let res = timeout(Duration::from_secs(2), long_op()).await;
```

### Select Macros

```rust
use tokio::select;

select! {
    res = task_a => handle(res?),
    msg = rx.recv() => process(msg),
    _ = shutdown.recv() => break,
}
```

### `Send + Sync` Audits

* **Library code** must be `!Send`‐safe unless API explicitly documents thread affinity.
* Use `crossbeam-channel` for fast MPMC.

---

## Security Best Practices

1. **Supply-chain hygiene**
   * `cargo audit` in CI.
   * Pin `Cargo.lock` for binaries; update via dependabot.
2. **Least Privilege**
   * Drop capabilities (`prctl`) before spawning child processes.
   * Use `sandboxfs`, `seccomp` on Linux.
3. **Deserialization Hardening**
   * Limit nesting depth / length when parsing untrusted input.
4. **Cryptography**
   * Use modern libs (`ring`, `rustls`, `age`) never DIY.
   * All secrets via `zeroize`.
5. **Unsafe Code Reviews**
   * Tag with `// SAFETY:` explaining invariants.
   * Each unsafe block must have paired test cases exercising edge inputs.
6. **Memory Disclosure**
   * Use `parking_lot::Mutex` to avoid poisoning panics leaking data.
7. **Web Attack Surface**
   * Set `SameSite`, `Secure`, `HttpOnly` on cookies via frameworks (`axum-extra`).

---

## Testing Strategies

### Pyramid

* **Unit (fast, pure)**: 70 %
* **Integration (real DB, http)**: 25 %
* **End-to-End (E2E)**: 5 %

### Property-based & Fuzzing

```rust
proptest! {
    #[test]
    fn addition_commutative(a in 0i64.., b in 0i64..) {
        prop_assert_eq!(a + b, b + a);
    }
}
```

Use `cargo fuzz` with an AFL or libFuzzer engine for parsers.

### Snapshot Testing

```rust
use insta::assert_json_snapshot;

assert_json_snapshot!(render_response(&req));
```

### Benchmarks with Criterion

```rust
criterion_group!(benches, bench_sort);
criterion_main!(benches);
```

Run via `cargo bench --features=bench`.

---

## Documentation Standards

* **Crate-level docs** go in `lib.rs` using `//!`.
* All **public items** must have `///` comments.
* Embed **`cargo doc --document-private-items`** warnings clean.
* Use *link-to-source* with `#[doc(cfg(feature = "foo"))]` on feature-gated APIs.

```rust
//! ## Quick Start
//! ```bash
//! cargo add my_crate
//! ```

/// Returns the nth Fibonacci number.
///
/// # Panics
/// Panics if `n` > 93 due to `u64` overflow.
pub fn fib(n: u8) -> u64 { ... }
```

---

## Code Style and Formatting

### `rustfmt.toml`

```
edition                  = "2024"
reorder_imports          = true
imports_granularity      = "Crate"
use_field_init_shorthand = true
tab_spaces               = 4
wrap_comments            = true
```

### Clippy Configuration (workspace-wide)

```toml
[workspace.lints.rust]
unsafe_code = "forbid"

[workspace.lints.clippy]
unwrap_used      = "deny"
expect_used      = "deny"
needless_borrow  = "warn"
string_slice     = "warn"
```

### Pre-commit Hook

```bash
#!/usr/bin/env bash
cargo fmt --all
cargo clippy --workspace --all-targets -- -D warnings
cargo test --workspace --all-targets
```

---

## Project Structure

### Single Crate vs Workspace

*Use a workspace when:*

* multiple binaries share a common lib
* independent microservices live under one repo
* you need fine-grained feature ownership & CI caching

```toml
# root/Cargo.toml
[workspace]
members = [
    "crates/core",
    "crates/web",
    "crates/cli",
]
resolver = "2"

[workspace.lints]
rust.workspace = true
clippy.workspace = true
```

Each member crate has its own `Cargo.toml` but inherits lint config.

### SemVer & Release Flow

1. Bump crate version in `Cargo.toml`.
2. Tag commit: `git tag -s v0.3.0`.
3. `cargo publish --workspace --allow-dirty`.
4. Update CHANGELOG.

---

## Essential Crates and Ecosystem

| Category      | Crate                               | Notes                                        |
| ------------- | ----------------------------------- | -------------------------------------------- |
| Serialization | `serde` + `serde_json`, `rmp-serde` | JSON / MessagePack                           |
| Async Runtime | `tokio`, `async-std`                | Default to Tokio for ecosystem richness      |
| Web Server    | `axum`, `actix-web`                 | Axum favours type safety                     |
| HTTP Client   | `reqwest`                           | Iceboxed TLS via `rustls-tls`                |
| Database      | `sqlx`, `sea-orm`                   | Compile-time query checks via `offline` mode |
| CLI           | `clap` v4                           | Typed derive macros                          |
| Observability | `tracing`, `opentelemetry`          | Structured logs + metrics                    |
| Caching       | `moka`, `redis`                     | Local LRU vs distributed                     |
| Testing       | `criterion`, `proptest`, `insta`    | Bench, property, snapshots                   |
| Crypto        | `ring`, `bcrypt`, `argon2`          | Memory-hard hashing                          |
| File IO       | `tokio-fs`, `walkdir`               | Async & recursive ops                        |

---

## Debugging and Tooling

### Runtime Debugging

* **`RUST_BACKTRACE=full`** for symbolized stack traces.
* **`tokio-console`** to inspect tasks & waker churn.
* **`cargo-nextest`** for test-runner parallelism.

### Static Analysis

* **`cargo-udeps`** — detect unused dependencies.
* **`cargo-machete`** — unused features.
* **`cargo-geiger`** — count `unsafe` lines.

### Advanced Tools

| Tool                 | Purpose                             |
| -------------------- | ----------------------------------- |
| `miri`               | UB detector: run `cargo miri test`. |
| `valgrind`/`dh-mem`  | Detect leaks in `unsafe` FFI.       |
| `perf`, `flamegraph` | CPU sampling & flame charts.        |
| `cargo-doctor`       | Diagnose broken toolchains.         |

---

## Appendix — Rule Summary

* Treat every Clippy warning as a bug; deny in CI.
* public APIs must be documented & covered by tests.
* Avoid `&mut self` async methods unless boxed.
* Secure defaults > configuration toggles.
* Delete dead code promptly — *code has cost even when disabled.*